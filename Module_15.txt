Filesystem Hierarchy Standard (FHS):
Previously, you learned that the Filesystem Hierarchy Standard (FHS) is the component of Linux that organizes data. The FHS is 
important because it defines how directories, directory contents, and other storage is organized in the operating system.

Under the FHS, a file’s location can be described by a file path. A file path is the location of a file or directory. In the file 
path, the different levels of the hierarchy are separated by a forward slash (/).

 Root directory:
 The root directory is the highest-level directory in Linux, and it’s always represented with a forward slash (/).  All 
 subdirectories branch off the root directory. Subdirectories can continue branching out to as many levels as necessary.

 Standard FHS directories:
 Directly below the root directory, you’ll find standard FHS directories. Here are a few examples of what standard directories 
 contain:

 ->/home: Each user in the system gets their own home directory.

 ->/bin: This directory stands for “binary” and contains binary files and other executables. Executables are files that contain a 
   series of commands a computer needs to follow to run programs and perform other functions.

 ->/etc: This directory stores the system’s configuration files.

 ->/tmp: This directory stores many temporary files. The /tmp directory is commonly used by attackers because anyone in the system 
   can modify data in these files.

 ->/mnt: This directory stands for “mount” and stores media, such as USB drives and hard drives.

 Pro Tip: You can use the man hier command to learn more about the FHS and its standard directories.

 User-specific subdirectories:
 Under home are subdirectories for specific users. Each user has their own personal subdirectories, such as projects, logs, or 
 reports.

 Note: When the path leads to a subdirectory below the user’s home directory, the user’s home directory can be represented as the 
 tilde (~). For example, /home/analyst/logs can also be represented as ~/logs.

 You can navigate to specific subdirectories using their absolute or relative file paths. The absolute file path is the full file 
 path, which starts from the root. For example, /home/analyst/projects is an absolute file path. The relative file path is the 
 file path that starts from a user's current directory.

 Note: Relative file paths can use a dot (.) to represent the current directory, or two dots (..) to represent the parent of the 
 current directory. An example of a relative file path could be ../projects.

Helpful navigation tips and keyboard shortcuts:
The following contains a list of navigation tips and keyboard shortcuts you may find useful when completing your Linux labs. 
Your cursor must be in the terminal window to use these navigation tips and keyboard shortcuts.

->CTRL + C: Terminates a command that is currently running; from the instructions portion of Qwiklabs, you can use CTRL + C to copy,
but within the terminal, it will only terminate a command and if one isn't running, it will display ^C at the prompt

->CTRL + V: Pastes text

->CTRL + A: Sets your cursor at the beginning of a command

->CTRL + E: Sets your cursor at the end of a command

->Left arrow key: Moves left within a command

->Right arrow key: Moves right within a command

->Up arrow key: Provides the last command you entered into the command line; can be entered multiple times to go through multiple 
  commands from the command history

->Down arrow key: Provides the next command in the command history; must be after using the up arrow key

->Tab key: Provides available suggestions for completing your text

Linux Commands:

 Basic Commands:

  ->application_name: To check if the apllication is installed.

  ->application_name --version: To check the version of installed application.

  ->sudo apt install application_name: To install the application.

  ->sudo apt remove application_name: To uninstall the application.

  ->apt list --installed: It gives the list of application installed.

  ->clear: Clears the terminal screen; this can also be done by entering CTRL + L.

  ->echo: This command in the Bash shell outputs a specified string of text.

  ->expr: This command performs basic mathematical calculation. (put space between the operands and operators)

 Commands for navigating the file system:

  ->pwd: Prints the working directory onto the screen.

  ->ls: Displays the names of files and directories in the current working directory.
   
    Note: If you want to return the contents of a directory that’s not your current working directory, you can add an argument 
    after ls with the absolute or relative file path to the desired directory. For example, if you’re in the /home/analyst 
    directory but want to list the contents of its projects subdirectory, you can enter ls /home/analyst/projects or just ls 
    projects.

  ->cd: Navigates between directories.

    Pro Tip: You can use the relative file path and enter cd .. to go up one level in the file structure. For example, if the 
    current directory is /home/analyst/projects, entering cd .. would change your working directory to /home/analyst. 

  ->cat file_name: Displays the content of a file. 

  ->whoami: This command returns the username of the current user. 
 
  ->head file_name: Displays just the beginning of a file, by default 10 lines.
   
    Pro Tip: If you want to change the number of lines returned by head, you can specify the number of lines by including -n. 
    For example, if you only want to display the first five lines of the updates.txt file, enter head -n 5 updates.txt.

  ->tail file_name: Displays just the end of a file, by default 10 lines.

  ->less file_name: The less command returns the content of a file one page at a time. For example, entering less updates.txt 
    changes the terminal window to display the contents of updates.txt one page at a time. This allows you to easily move forward 
    and backward through the content. 

    Once you’ve accessed your content with the less command, you can use several keyboard controls to move through the file:

     Space bar: Move forward one page

     b: Move back one page

     Down arrow: Move forward one line

     Up arrow: Move back one line

     q: Quit and return to the previous terminal window

 Filtering Commands:-

  ->grep specific_string file_name: This command searches a specified file and returns all lines in the file containing a 
    specified string or text. It commonly takes two arguments: a specific string to search for and a specific file to search 
    through. Use " " for more than two or more words string.

  ->Pipe(|): Piping sends the standard output of one command as standard input to another command for further processing. When 
    used with grep, the pipe can help you find directories and files containing a specific word in their names. For example, 
    ls /home/analyst/reports | grep users returns the file and directory names in the reports directory that contain users. 
    Before the pipe, ls indicates to list the names of the files and directories in reports. Then, it sends this output to the 
    command after the pipe. In this case, grep users returns all of the file or directory names containing users from the input 
    it received. 

  Note: Piping is a general form of redirection in Linux and can be used for multiple tasks other than filtering. You can think 
  of piping as a general tool that you can use whenever you want the output of one command to become the input of another command.

  ->find: The find command searches for directories and files that meet specified criteria. There’s a wide range of criteria that 
    can be specified with find. For example, you can search for files and directories that

    Contain a specific string in the name,

    Are a certain file size, or

    Were last modified within a certain time frame.

    When using find, the first argument after find indicates where to start searching. For example, entering find 
    /home/analyst/projects searches for everything starting at the projects directory. 

    After this first argument, you need to indicate your criteria for the search. If you don’t include a specific search criteria 
    with your second argument, your search will likely return a lot of directories and files. 

    Specifying criteria involves options. Options modify the behavior of a command and commonly begin with a hyphen (-). 

    -->-name and -iname:
       One key criteria analysts might use with find is to find file or directory names that contain a specific string. The 
       pecific string you’re searching for must be entered in quotes after the -name or -iname options. The difference between 
       these two options is that -name is case-sensitive, and -iname is not. 

       For example, you might want to find all files in the projects directory that contain the word “log” in the file name. To 
       do this, you’d enter find /home/analyst/projects -name "*log*". You could also enter find /home/analyst/projects -iname "*log*".

       In these examples, the output would be all files in the projects directory that contain log surrounded by zero or more 
       characters. The "*log*" portion of the command is the search criteria that indicates to search for the string “log”. 
       When -name is the option, files with names that include Log or LOG, for example, wouldn’t be returned because this option 
       is case-sensitive. However, they would be returned when -iname is the option.

       Note: An asterisk (*) is used as a wildcard to represent zero or more unknown characters.

    -->-mtime:
       Security analysts might also use find to find files or directories last modified within a certain time frame. The -mtime 
       option can be used for this search. For example, entering find /home/analyst/projects -mtime -3 returns all files and 
       directories in the projects directory that have been modified within the past three days. 

       The -mtime option search is based on days, so entering -mtime +1 indicates all files or directories last modified more than 
       one day ago, and entering -mtime -1 indicates all files or directories last modified less than one day ago. 

       Note: The option -mmin can be used instead of -mtime if you want to base the search on minutes rather than days.


 Creating and modifying directories/files:

  ->mkdir: The mkdir command creates a new directory. For example, if you want to create a new directory called network in your 
    /home/analyst/logs directory, you can enter mkdir /home/analyst/logs/network to create this new directory. If you’re already 
    in the /home/analyst/logs directory, you can also create this new directory by entering mkdir network.

  ->rmdir: The rmdir command removes, or deletes, a directory. For example, entering rmdir /home/analyst/logs/network would 
    remove this empty directory from the file system.

    Note: The rmdir command cannot delete directories with files or subdirectories inside.It will return error.

  ->touch: The touch command creates a new file. If your current directory is /home/analyst/reports, entering touch permissions.txt 
    creates a new file in the reports subdirectory called permissions.txt.

  ->rm: The rm command removes, or deletes, a file. This command should be used carefully because it’s not easy to recover files 
    deleted with rm. To remove the permissions file you just created, enter rm permissions.txt. 

  ->mv: This command moves a file or directory to a new location. The first argument after mv is the file or directory you want to 
    move , and the second argument is the location you want to move. To move permissions.txt into the logs subdirectory, enter mv 
    permissions.txt /home/analyst/logs. Moving a file removes the file from its original location.

  Note: The mv command can also be used to rename files. To rename a file, pass the new name in as the second argument instead of 
  the new location. For example, entering mv permissions.txt perm.txt renames the permissions.txt file to perm.txt.

  ->cp: This command copies a file or directory into a new location. The first argument after cp is the file or directory you want 
    to copy, and the second argument is the location you want to copy it to. To copy permissions.txt into the logs subdirectory 
    while also keeping it in its original location, enter cp permissions.txt /home/analyst/logs.

 nano text editor:
 nano is a command-line file editor that is available by default in many Linux distributions. You can perform multiple basic tasks 
 in nano, such as creating new files and modifying file contents. To open an existing file in nano from the directory that contains 
 it, enter nano followed by the file name. For example, entering nano permissions.txt from the /home/analyst/reports directory 
 opens a new nano editing window with the permissions.txt file open for editing. You can also provide the absolute file path to 
 the file if you’re not in the directory that contains it.You can also create a new file in nano by entering nano followed by a 
 new file name. For example, entering nano authorized_users.txt from the /home/analyst/reports directory creates the 
 authorized_users.txt file within that directory and opens it in a new nano editing window. Since there isn't an auto-saving 
 feature in nano, it’s important to save your work before exiting. To save a file in nano, use the keyboard shortcut Ctrl + O. 
 You’ll be prompted to confirm the file name before saving. To exit out of nano, use the keyboard shortcut Ctrl + X.

 Note: Vim and Emacs are also popular command-line text editors.

 Standard output redirection:
 There’s an additional way you can write to files. Previously, you learned about standard input and standard output. Standard 
 input is information received by the OS via the command line, and standard output is information returned by the OS through the 
 shell.

 You’ve also learned about piping. Piping sends the standard output of one command as standard input to another command for 
 further processing. It uses the pipe character (|). 

 In addition to the pipe (|), you can also use the right angle bracket (>) and double right angle bracket (>>) operators to 
 redirect standard output.

 When used with echo, the > and >> operators can be used to send the output of echo to a specified file rather than the screen. 
 The difference between the two is that > overwrites your existing file, and >> adds your content to the end of the existing file 
 instead of overwriting it. The > operator should be used carefully, because it’s not easy to recover overwritten files.

 When you’re inside the directory containing the permissions.txt file, entering echo "last updated date" >> permissions.txt adds 
 the string “last updated date” to the file contents. Entering echo "time" > permissions.txt after this command overwrites the 
 entire file contents of permissions.txt with the string “time”.

 Note: Both the > and >> operators will create a new file if one doesn’t already exist with your specified name.

 Permission Commands:

 ->ls -a: Displays hidden files. Hidden files start with a period (.) at the beginning.

 ->ls -l: Displays permissions to files and directories. Also displays other additional information, including owner name, group, 
   file size, and the time of last modification.

 ->ls -la: Displays permissions to files and directories, including hidden files. This is a combination of the other two options.

 ->chmod :ls -la: Displays permissions to files and directories, including hidden files. This is a combination of the other two 
   options.For example, the following command would add all permissions to login_sessions.txt: 
   
   chmod u+rwx,g+rwx,o+rwx login_sessions.txt 
   
   If you wanted to take all the permissions away, you could use

   chmod u-rwx,g-rwx,o-rwx login_sessions.txt

   Another way to assign these permissions is to use the equals sign (=) in this first argument. Using = with chmod sets, or 
   assigns, the permissions exactly as specified. For example, the following command would set read permissions for 
   login_sessions.txt for user, group, and other:

   chmod u=r,g=r,o=r login_sessions.txt

 Authentication and Authorization Commands:

 ->useradd:
   The useradd command adds a user to the system. To add a user with the username of fgarcia with sudo, enter sudo useradd fgarcia. 
   There are additional options you can use with useradd:

   -g: Sets the user’s default group, also called their primary group

   -G: Adds the user to additional groups, also called supplemental or secondary groups

   To use the -g option, the primary group must be specified after -g. For example, entering sudo useradd -g security fgarcia adds 
   fgarcia as a new user and assigns their primary group to be security.

   To use the -G option, the supplemental group must be passed into the command after -G. You can add more than one supplemental 
   group at a time with the -G option. Entering sudo useradd -G finance,admin fgarcia adds fgarcia as a new user and adds them to 
   the existing finance and admin groups.

